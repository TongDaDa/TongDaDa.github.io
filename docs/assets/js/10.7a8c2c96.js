(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{365:function(t,a,e){t.exports=e.p+"assets/img/typewriter2.e00b4bcf.png"},366:function(t,a,e){t.exports=e.p+"assets/img/typewriter.7c682dda.png"},367:function(t,a,e){t.exports=e.p+"assets/img/UtfCharsetList.9b03794f.png"},489:function(t,a,e){"use strict";e.r(a);var v=e(4),s=Object(v.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("blockquote",[v("p",[t._v("这段时间，在github上贡献了一个读取媒体头文件的library，此作者的repos中有很多关于字符编码的库，而且作者很给力，有任何不懂的问题和想要了解的东西可以给他发issue，热爱讨论，然后我以一个学习者的身份，把关于编码的一些repo fork了下来，顺便和最近正在读的《隐匿在计算机后的编码》串起来总结一下。")])]),t._v(" "),v("br"),t._v(" "),v("h2",{attrs:{id:"计算机的编码结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算机的编码结构"}},[t._v("#")]),t._v(" 计算机的编码结构")]),t._v(" "),v("p",[t._v("计算机说白了就是一个集成电路(Interge circuit)，电路可以形成逻辑，"),v("code",[t._v("逻辑")]),t._v("作为形式上的计算机最小运算单元，我们通常把它称作为布尔值。布尔值慕名思意来源于布尔代数，它是数学家布尔发明了用数学表达逻辑的运算方式😂，发明了很多年之后，布尔代数才与电路相互结合，然后出现我们现在比较熟悉的"),v("code",[t._v("逻辑门")]),t._v("，"),v("code",[t._v("触发器")]),t._v("，"),v("code",[t._v("晶体管")]),t._v(", "),v("code",[t._v("加法器")]),t._v(", "),v("code",[t._v("继电器")]),t._v("，其实继电器是比计算机出现的早得多，早在电报时期它就被发明出来，主要的目的是刷新电压提高电流以传输得更远，但是后来继电器不仅仅是"),v("code",[t._v("继电")]),t._v("那么简单，玩法开始越来越多，这个后面会提一下。")]),t._v(" "),v("p",[t._v("以上只是随便说了点历史和硬件，这里只需了解电路和二进制和逻辑的关系，逻辑最小可解构为两个部分，分别为1,0，也就是是或者否，二进制表示为0或者1，它们完全符合电路的打开和闭合的规则。所以任何事情在计算机中，都无非是电路的闭合或开关组成的。")]),t._v(" "),v("h3",{attrs:{id:"二进制-binary"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二进制-binary"}},[t._v("#")]),t._v(" 二进制(Binary)")]),t._v(" "),v("p",[t._v("通过上面，我们知道二进制只是符合计算机运算规律的进制数，就好比我们人类擅长使用10进制来计算一样，我们在代码中一般都会使用10进制数字进行运行，甚至是8进制，16进制等等各类表示方法，总之怎么方便计算，方便表示，我们就用几进制，但是总归该是要转换成2进制给计算机的，这也就是我们编译器做的事情，对于运行时语言，则又多了一层"),v("code",[t._v("控制层语言")]),t._v("也就是母语言，就比如js的外面包裹着c++。")]),t._v(" "),v("h3",{attrs:{id:"unicode"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#unicode"}},[t._v("#")]),t._v(" Unicode")]),t._v(" "),v("p",[t._v("我们不能在计算机中直接输入二进制来下命令，因为它不符合我们的大脑意识，也就影响了效率，所以我们需要搞出一个更易于人类使用。所以我们需要一个可以转换字符的工具，把我们熟悉的字符比如中文和abcd转换到二进制，这就是Unicode码的作用，自11.0版本以来，Unicode已经支持了十三万多个字符，也包含了很多小语种，它是一个映射表，从码点(code point)映射到字形(glyphs)，我们输入的每个字母，这个字母的字形对应到一个唯一的 code point，关于字形与code point的对应，可以参考[Unicdeo官方文档][1]，这里只需了解每个字形(不受字体样式的影响)都对应一个码点，这就是unicode做的事情。")]),t._v(" "),v("p",[t._v("code point的设计也很好理解，它是纯数字，从0开始递增，分别表示各个国家的各种语言字符，大致分两个部分，一个是"),v("code",[t._v("无字形")]),t._v("编码主要用于格式的处理和一些在特定系统和编码下的功能键，它被分为c0和c1两个部分，比如换行的code point就是10，属于c0部分，另一个部分属于"),v("code",[t._v("有字形")]),t._v("部分，就像我们刚才说的，它们都对应一个特殊的glyphs，其中就有Ascill。")]),t._v(" "),v("h4",{attrs:{id:"ascii码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ascii码"}},[t._v("#")]),t._v(" Ascii码")]),t._v(" "),v("p",[t._v("Ascii的历史有点远了，最初的设计也是为了"),v("code",[t._v("电传打字机")]),t._v("，附图:\n"),v("img",{attrs:{src:e(365),alt:"clipboard.png"}}),t._v("，")]),t._v(" "),v("p",[t._v("看不清？来个放大版的。\n"),v("img",{attrs:{src:e(366),alt:"clipboard.png"}}),t._v("，")]),t._v(" "),v("p",[t._v("看起来，它只是一个输出设备，可以使用键盘打字，然后输出到纸上。")]),t._v(" "),v("p",[t._v("Ascii码和uncide一样也是通过数字来映射对应的字符(这是毋庸置疑的，就像我们上面说的计算机的本源就是"),v("code",[t._v("断开")]),t._v("和"),v("code",[t._v("闭合")]),t._v("，只不过上层我们习惯用十进制，底层是二进制)，起初它的范围只有0-127，也就是128个字符，Ascii码也正是从0-127对应这128个Ascii字符的，我们平时的书写格式有很多种，比如换行，空格，制表符，等等。Ascii的前32个字符就是这种"),v("strong",[t._v("无实际字形的码点")]),t._v("，它只表示文本的格式，再之后的字符就是一些标点符号和阿拉伯数字，和拉丁字母(Latin Letter)，拉丁字母支持大小写，具体请查看[here][2]。")]),t._v(" "),v("p",[t._v("Ascii前期只有128个字符，同期也有很多和它相似的编码，比如"),v("code",[t._v("ISO 646")]),t._v("，它支持除了Ascii支持的编码外更多国家的字符，也有很多编码支持的因为它在西方的字符通用性(Latin letter 在西方使用广泛)被使用的越来越多，")]),t._v(" "),v("p",[t._v("Ascii和Unicode的交集就在于这128个字符，Unicode的前128个字符也恰恰采用了这些字符，对于前期的Ascii码是完全兼容Unicode的，或者说Unicode就是Ascii码的超集(Superset)，")]),t._v(" "),v("p",[t._v("但是对于"),v("code",[t._v("扩展的Ascii字符(Extended Ascii Codes)")]),t._v("，Unicode并没有对应，我想或许这是因为Unicode定义晚于扩展的Ascii字符。")]),t._v(" "),v("p",[t._v("我们可以通过javascript打印看一下32个字符是没有字形的，并且可以发现前128个字符是完全和Ascii码相等的。")]),t._v(" "),v("h3",{attrs:{id:"上层编码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#上层编码"}},[t._v("#")]),t._v(" 上层编码")]),t._v(" "),v("p",[t._v("Unicode只是提供了一个映射表(Map table)，直接使用它来解决"),v("code",[t._v("两种语言")]),t._v("(Binary 和 字符)的转换中间还差了一道工序。想象一下假如让我们来使用Unicode码来设计一个刚才的打字机？")]),t._v(" "),v("p",[t._v("我现在想打印四个字："),v("code",[t._v("我喜欢你")]),t._v("，我们使用打字机输入四个字符，然后打字机通过使用Unicode的Map把他们转换成字符序列.")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("11000100,0010001 // 我\n10101011,0011100 // 喜\n11010110,0100010 // 欢\n10011110,1100000 // 你\n")])])]),v("p",[t._v("假如我们没有任何修饰符，我们将这些二进制序列合起来就是通过unicode转换出来的这四个字。")]),t._v(" "),v("p",[t._v("但把它们放在一起，会出现一个问题。比如，我们把"),v("code",[t._v("我")]),t._v("字第一个字节的序列拿出来，同样也是一个字符。")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('String.fromCodePoint(parseInt("11000100",2)); // "Ä"\n')])])]),v("p",[t._v("所以，计算机不知道到底多少个字节才是一个字符，一定要有一个上层规范再包装一下Uicode的这个映射表，计算机才能更清晰正确的组合这些bit。我们比较常用的 UTF系列和GBK，windows UCS等等很多编码，它们其实都是处理的这部分事情，最大不同点是"),v("code",[t._v("它们的算法(组合序列映射为字符的算法)不一样，支持的字符也不相同")]),t._v("。")]),t._v(" "),v("p",[t._v("大部分我们熟知的编码都是"),v("code",[t._v("为了建立在更少的码点占用内存和查找效率的基础上，更好的解析不同场景的Unicode码")]),t._v("。比如下面")]),t._v(" "),v("h4",{attrs:{id:"utf-8，utf-16，utf-32"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#utf-8，utf-16，utf-32"}},[t._v("#")]),t._v(" Utf-8，Utf-16，Utf-32")]),t._v(" "),v("p",[v("code",[t._v("UTF(Unicode Transformation Format)")]),t._v("系列编码直译为Unicode转换格式。它们基于Unicode定义了一些自己的规则。")]),t._v(" "),v("p",[t._v("先了解一波名词：")]),t._v(" "),v("p",[v("code",[t._v("码元(Code Unit)")]),t._v(" "),v("code",[t._v("Unicode平面")]),t._v(" "),v("code",[t._v("字符映射（character map）")]),t._v(" "),v("code",[t._v("字节序")]),t._v(" "),v("code",[t._v("前导位")])]),t._v(" "),v("p",[t._v("####UTF-8\nUtf-8与ASCII完全兼容，它的定义规则是这样的，贴一张图。\n"),v("img",{attrs:{src:e(367),alt:"clipboard.png"}}),t._v("\n####UTF-16\n####UTF-32")]),t._v(" "),v("h4",{attrs:{id:"gbk"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gbk"}},[t._v("#")]),t._v(" GBK")]),t._v(" "),v("h4",{attrs:{id:"ucs"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ucs"}},[t._v("#")]),t._v(" UCS")]),t._v(" "),v("h4",{attrs:{id:"big"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#big"}},[t._v("#")]),t._v(" Big")]),t._v(" "),v("h3",{attrs:{id:"编码可能导致的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#编码可能导致的问题"}},[t._v("#")]),t._v(" 编码可能导致的问题")]),t._v(" "),v("p",[t._v("####乱码\n编码出现的地方有两种，我们在代码编辑器中编辑时的编码，解析时编码，比如HTML中的元标签(meta)第一行我们通常都会指定一个charset。")]),t._v(" "),v("p",[t._v("总之，编码也就是两部分，第一是你用什么编码写入的这个文件，第二是运行上下文使用什么编码来解析这个文件，两头对不上，那就会出现乱码的情况。\n####看起来一模一样，但却不相等？\n####看着没什么，但")]),t._v(" "),v("h3",{attrs:{id:"加密编码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#加密编码"}},[t._v("#")]),t._v(" 加密编码")]),t._v(" "),v("p",[t._v("加密编码和上面说的普通编码不同，前者为了保护数据，后者为了显示。\n对于非对称加密，加密有 SHA, SHA-1, MD5, HEX, 我通常叫这种加密方式为"),v("code",[t._v("加盐")]),t._v("。")]),t._v(" "),v("p",[t._v("对称编码，和对称加密，我们熟知的base64和Zip压缩算法等等，对称加密就需要提供一对秘钥")]),t._v(" "),v("h3",{attrs:{id:"如何互相转各类编码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何互相转各类编码"}},[t._v("#")]),t._v(" 如何互相转各类编码")]),t._v(" "),v("p",[t._v("对于各类的上层编码我们应该如何转换呢？")]),t._v(" "),v("h3",{attrs:{id:"with-javascript"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#with-javascript"}},[t._v("#")]),t._v(" With JavaScript")]),t._v(" "),v("p",[v("strong",[t._v("千万不要被字符表象所迷惑，时刻铭记着，屏幕上的字符只是CodePoint的映射(Map)")]),t._v("。")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('var s = String.fromCharCode(1)\nvar d = String.fromCharCode(3);\nconsole.log(d) // ""\nconsole.log(s) // ""\ns === ""; //false\nd === ""; //false\ns > d; // false\nd > s; //true\n')])])]),v("p",[t._v("由于32码点之内的字符是"),v("code",[t._v("无字形")]),t._v("的，所以我们打印出来并不能看到什么，但实际上在比较时，引擎还是以codePoint为准。自然排序也就是Sort方法也是比较码点了。")]),t._v(" "),v("h3",{attrs:{id:"with-java"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#with-java"}},[t._v("#")]),t._v(" With Java")]),t._v(" "),v("h3",{attrs:{id:"with-python"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#with-python"}},[t._v("#")]),t._v(" With Python")]),t._v(" "),v("h3",{attrs:{id:"with-practice"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#with-practice"}},[t._v("#")]),t._v(" With Practice")]),t._v(" "),v("p",[t._v("我们可以在代码中直接使用Unicode码，这需要使用\\u前缀标明接下来应该被识别为对应"),v("code",[t._v("编码类型")]),t._v("的转义后的字符。")])])}),[],!1,null,null,null);a.default=s.exports}}]);